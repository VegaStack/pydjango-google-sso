{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-django-google-sso","title":"Welcome to Django Google SSO","text":""},{"location":"#motivation","title":"Motivation","text":"<p>This library aims to simplify the process of authenticating users with Google in Django Admin pages, inspired by libraries like django_microsoft_auth and django-admin-sso</p>"},{"location":"#why-another-library","title":"Why another library?","text":"<ul> <li> <p>This library aims for simplicity and ease of use. django-allauth is   de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates.   Django-Google-SSO just add the \"Login with Google\" button in the default login page.</p> Light ModeDark Mode <p></p> <p></p> </li> <li> <p>django-admin-sso is a good solution, but it uses a deprecated   google <code>auth2client</code> version.</p> </li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install django-google-sso\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.9, 3.10 and 3.11</li> <li>Django 4.0, 4.1 and 4.2 For python 3.8 please use version 2.x</li> </ul>"},{"location":"admin/","title":"Using Django Admin","text":"<p>Django Google SSO integrates with Django Admin, adding an Inline Model Admin to the User model. This way, you can access the Google SSO data for each user.</p>"},{"location":"admin/#using-custom-user-model","title":"Using Custom User model","text":"<p>If you are using a custom user model, you may need to add the <code>GoogleSSOInlineAdmin</code> inline model admin to your custom user model admin, like this:</p> <pre><code># admin.py\nfrom django.contrib import admin\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.admin import UserAdmin\nfrom django_google_sso.admin import GoogleSSOInlineAdmin\nCustomUser = get_user_model()\nif admin.site.is_registered(CustomUser):\nadmin.site.unregister(CustomUser)\n@admin.register(CustomUser)\nclass CustomUserAdmin(UserAdmin):\ninlines = [GoogleSSOInlineAdmin]\n</code></pre>"},{"location":"callback/","title":"Get your Callback URI","text":"<p>The callback URL is the URL where Google will redirect the user after the authentication process. This URL must be registered in your Google project.</p>"},{"location":"callback/#the-callback-uri","title":"The Callback URI","text":"<p>The callback URI is composed of <code>{scheme}://{netloc}/{path}/</code>, where the netloc is the domain name of your Django project, and the path is <code>/google_sso/callback/</code>. For example, if your Django project is hosted on <code>https://myproject.com</code>, then the callback URL will be <code>https://myproject.com/google_sso/callback/</code>.</p> <p>So, let's break each part of this URI:</p>"},{"location":"callback/#the-scheme","title":"The scheme","text":"<p>The scheme is the protocol used to access the URL. It can be <code>http</code> or <code>https</code>. Django-Google-SSO will select the same scheme used by the URL which shows to you the login page.</p> <p>For example, if you're running locally, like <code>http://localhost:8000/accounts/login</code>, then the callback URL scheme will be <code>http://</code>.</p> How about a Reverse-Proxy? <p>If you're running Django behind a reverse-proxy, please make sure you're passing the correct <code>X-Forwarded-Proto</code> header to the login request URL.</p>"},{"location":"callback/#the-netloc","title":"The NetLoc","text":"<p>The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: <code>example.com</code>, <code>localhost:8000</code>, <code>api.my-domain.com</code>, and so on. To find the correct netloc, Django-Google-SSO will check, in that order:</p> <ul> <li>If settings contain the variable <code>GOOGLE_SSO_CALLBACK_DOMAIN</code>, it will use this value.</li> <li>If Sites Framework is active, it will use the domain field for the current site.</li> <li>The netloc found in the URL which shows you the login page.</li> </ul>"},{"location":"callback/#the-path","title":"The Path","text":"<p>The path is the path to the callback view. It will be always <code>/&lt;path in urls.py&gt;/callback/</code>.</p> <p>Remember when you add this to the <code>urls.py</code>?</p> <pre><code>from django.urls import include, path\nurlpatterns = [\n# other urlpatterns...\npath(\n\"google_sso/\", include(\n\"django_google_sso.urls\",\nnamespace=\"django_google_sso\"\n)\n),\n]\n</code></pre> <p>The path starts with the <code>google_sso/</code> part. If you change this to <code>sso/</code> for example, your callback URL will change to <code>https://myproject.com/sso/callback/</code>.</p>"},{"location":"callback/#registering-the-uri","title":"Registering the URI","text":"<p>To register the callback URL, in your Google project, add the callback URL in the Authorized redirect URIs field, clicking on button <code>Add URI</code>. Then add your full URL and click on <code>Save</code>.</p> <p>Do not forget the trailing slash</p> <p>Many errors on this step are caused by forgetting the trailing slash:</p> <ul> <li>Good: <code>http://localhost:8000/google_sso/callback/</code></li> <li>Bad: <code>http://localhost:8000/google_sso/callback</code></li> </ul> <p>In the next step, we will configure Django-Google-SSO to auto create the Users.</p>"},{"location":"credentials/","title":"Adding Google Credentials","text":"<p>To make the SSO work, we need to set up, in your Django project, the Google credentials needed to perform the authentication.</p>"},{"location":"credentials/#getting-google-credentials","title":"Getting Google Credentials","text":"<p>In your Google Console navigate to Api -&gt; Credentials to access the credentials for your all Google Cloud Projects.</p> <p>Your first Google Cloud Project</p> <p>If you don't have a Google Cloud Project, you can create one by clicking on the Create button.</p> <p>Then, you can select one of existing Web App Oauth 2.0 Client Ids in your Google project, or create a new one.</p> Do I need to create a new Oauth 2.0 Client Web App? <p>Normally you will have one credential per environment in your Django project. For example, if you have a development, staging and production environments, then you will have three credentials, one for each one. This mitigates the risk of exposing all your data in case of a security breach.</p> <p>If you decide to create a new one, please check https://developers.google.com/identity/protocols/oauth2/ for additional info.</p> <p>When you open your Web App Client Id, please get the following information:</p> <ul> <li>The Client ID. This is something like <code>XXXX.apps.googleusercontent.com</code> and will be the <code>GOOGLE_SSO_CLIENT_ID</code> in   your Django project.</li> <li>The Client Secret Key. This is a long string and will be the <code>GOOGLE_SSO_CLIENT_SECRET</code> in your Django project.</li> <li>The Project ID. This is the Project ID, you can get click on the Project Name, and will be   the <code>GOOGLE_SSO_PROJECT_ID</code> in your Django project.</li> </ul> <p>After that, add them in your <code>settings.py</code> file:</p> <pre><code># settings.py\nGOOGLE_SSO_CLIENT_ID = \"your client id here\"\nGOOGLE_SSO_CLIENT_SECRET = \"your client secret here\"\nGOOGLE_SSO_PROJECT_ID = \"your project id here\"\n</code></pre> <p>Don't commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we recommend you to use environment variables to store this info. To read this data, we recommend you to install and use a Twelve-factor compatible library in your project.</p> <p>For example, you can use our sister project Stela to load the environment variables from a <code>.env.local</code> file, like this:</p> <pre><code># .env.local\nGOOGLE_SSO_CLIENT_ID=\"your client id here\"\nGOOGLE_SSO_CLIENT_SECRET=\"your client secret here\"\nGOOGLE_SSO_PROJECT_ID=\"your project id here\"\n</code></pre> <pre><code># Django settings.py\nfrom stela import env\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\n</code></pre> <p>But in fact, you can use any library you want, like django-environ, django-constance, python-dotenv, etc...</p> <p>In the next step, we need to configure the authorized callback URI for your Django project.</p>"},{"location":"how/","title":"How Django Google SSO works?","text":""},{"location":"how/#current-flow","title":"Current Flow","text":"<ol> <li> <p>First, the user is redirected to the Django login page. If settings <code>GOOGLE_SSO_ENABLED</code> is True, the \"Login with Google\" button will be added to a default form.</p> </li> <li> <p>On click, Django-Google-SSO will add, in a anonymous request session, the <code>next_path</code> and Google Flow <code>state</code>. This data will expire in 10 minutes. Then user will be redirected to Google login page.</p> <p>Using Request Anonymous session</p> <p>If you make any actions which change or destroy this session, like restart django, clear cookies or change browsers, the login will fail, and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again.</p> </li> <li> <p>On callback, Django-Google-SSO will check <code>code</code> and <code>state</code> received. If they are valid, Google's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in.</p> </li> <li> <p>Otherwise, the user will be created and logged in, if his email domain, matches one of the <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code>. You can disable the auto-creation setting <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> to False.</p> </li> <li> <p>On creation only, this user can be set to the<code>staff</code> or <code>superuser</code> status, if his email are in <code>GOOGLE_SSO_STAFF_LIST</code> or <code>GOOGLE_SSO_SUPERUSER_LIST</code> respectively. Please note if you add an email to one of these lists, the email domain must be added to <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code>too.</p> </li> <li> <p>This authenticated session will expire in 1 hour, or the time defined, in seconds, in <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code>.</p> </li> <li> <p>Browser will be redirected to <code>next_path</code> if operation succeeds, or the <code>login</code> page, if operation fails.</p> </li> </ol>"},{"location":"how/#using-custom-authentication-backend","title":"Using Custom Authentication Backend","text":"<p>If the users need to log in using a custom authentication backend, you can use the <code>GOOGLE_SSO_AUTHENTICATION_BACKEND</code> setting:</p> <pre><code># settings.py\nGOOGLE_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"\n</code></pre>"},{"location":"model/","title":"Getting Google info","text":""},{"location":"model/#the-user-model","title":"The User model","text":"<p>Django Google SSO saves in the database the following information from Google, using current <code>User</code> model:</p> <ul> <li><code>email</code>: The email address of the user.</li> <li><code>first_name</code>: The first name of the user.</li> <li><code>last_name</code>: The last name of the user.</li> <li><code>username</code>: The email address of the user.</li> <li><code>password</code>: An unusable password, generated using <code>get_unusable_password()</code> from Django.</li> </ul> <p>Getting data on code is straightforward:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\nuser = request.user\nreturn JsonResponse({\n\"email\": user.email,\n\"first_name\": user.first_name,\n\"last_name\": user.last_name,\n\"username\": user.username,\n})\n</code></pre>"},{"location":"model/#the-googlessouser-model","title":"The GoogleSSOUser model","text":"<p>Also, on the <code>GoogleSSOUser</code> model, it saves the following information:</p> <ul> <li><code>picture_url</code>: The URL of the user's profile picture.</li> <li><code>google_id</code>: The Google ID of the user.</li> <li><code>locale</code>: The preferred locale of the user.</li> </ul> <p>This is a one-to-one relationship with the <code>User</code> model, so you can access this data using the <code>googlessouser</code> reverse relation attribute:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\nuser = request.user\nreturn JsonResponse({\n\"email\": user.email,\n\"first_name\": user.first_name,\n\"last_name\": user.last_name,\n\"username\": user.username,\n\"picture\": user.googlessouser.picture_url,\n\"google_id\": user.googlessouser.google_id,\n\"locale\": user.googlessouser.locale,\n})\n</code></pre> <p>You can also import the model directly, like this:</p> <pre><code>from django_google_sso.models import GoogleSSOUser\ngoogle_info = GoogleSSOUser.objects.get(user=user)\n</code></pre>"},{"location":"model/#about-google-scopes","title":"About Google Scopes","text":"<p>To retrieve this data Django Google SSO uses the following scopes for Google OAuth 2.0:</p> <pre><code>GOOGLE_SSO_SCOPES = [  # Google default scope\n\"openid\",\n\"https://www.googleapis.com/auth/userinfo.email\",\n\"https://www.googleapis.com/auth/userinfo.profile\",\n]\n</code></pre> <p>You can change this scopes overriding the <code>GOOGLE_SSO_SCOPES</code> setting in your <code>settings.py</code> file. But if you ask the user to authorize more scopes, this plugin will not save this additional data in the database. You will need to implement your own logic to save this data, calling Google again.</p> <p>The main goal here is simplicity</p> <p>The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.</p>"},{"location":"quick_setup/","title":"Quick Setup","text":""},{"location":"quick_setup/#setup-django-settings","title":"Setup Django Settings","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\nINSTALLED_APPS = [\n# other django apps\n\"django.contrib.messages\",  # Need for Auth messages\n\"django_google_sso\",  # Add django_google_sso\n]\n</code></pre>"},{"location":"quick_setup/#setup-google-credentials","title":"Setup Google Credentials","text":"<p>Now, add your Google Project Web App API Credentials in your <code>settings.py</code>:</p> <pre><code># settings.py\nGOOGLE_SSO_CLIENT_ID = \"your Web App Client Id here\"\nGOOGLE_SSO_CLIENT_SECRET = \"your Web App Client Secret here\"\nGOOGLE_SSO_PROJECT_ID = \"your Google Project Id here\"\n</code></pre>"},{"location":"quick_setup/#setup-callback-uri","title":"Setup Callback URI","text":"<p>In Google Console at Api -&gt; Credentials -&gt; Oauth2 Client, add the following Authorized Redirect URI: <code>https://your-domain.com/google_sso/callback/</code> replacing <code>your-domain.com</code> with your real domain (and Port). For example, if you're running locally, you can use <code>http://localhost:8000/google_sso/callback/</code>.</p> <p>Do not forget the trailing slash!</p>"},{"location":"quick_setup/#setup-auto-create-users","title":"Setup Auto-Create Users","text":"<p>The next option is to set up the auto-create users from Django Google SSO. Only emails with the allowed domains will be created automatically. If the email is not in the allowed domains, the user will be redirected to the login page.</p> <pre><code># settings.py\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"your-domain.com\"]\n</code></pre>"},{"location":"quick_setup/#setup-django-urls","title":"Setup Django URLs","text":"<p>And in your <code>urls.py</code> please add the Django-Google-SSO views:</p> <pre><code># urls.py\nfrom django.urls import include, path\nurlpatterns = [\n# other urlpatterns...\npath(\n\"google_sso/\", include(\n\"django_google_sso.urls\",\nnamespace=\"django_google_sso\"\n)\n),\n]\n</code></pre>"},{"location":"quick_setup/#run-django-migrations","title":"Run Django migrations","text":"<p>Finally, run migrations</p> <pre><code>$ python manage.py migrate\n</code></pre> <p>And, that's it: Django Google SSO is ready for use. When you open the admin page, you will see the \"Login with Google\" button:</p> Light ModeDark Mode <p></p> <p></p> How about Django Admin skins, like Grappelli? <p>Django Google SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli, Django Jazzmin, Django Admin Interface and Django Jet Reboot.</p> <p>If the skin uses his own login template, the \"Login with Google\" button will not be displayed.</p> <p>For the next pages, let's see each one of these steps with more details.</p>"},{"location":"settings/","title":"All Django Settings options","text":"Setting Description <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code> List of domains that will be allowed to create users. Default: <code>[]</code> <code>GOOGLE_SSO_AUTHENTICATION_BACKEND</code> The authentication backend to use.  Default: <code>None</code> <code>GOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER</code> If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: <code>False</code> <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> Enable or disable the auto-create users feature. Default: <code>True</code> <code>GOOGLE_SSO_CALLBACK_DOMAIN</code> The netloc to be used on Callback URI. Default: <code>None</code> <code>GOOGLE_SSO_CLIENT_ID</code> The Google OAuth 2.0 Web Application Client ID. Default: <code>None</code> <code>GOOGLE_SSO_CLIENT_SECRET</code> The Google OAuth 2.0 Web Application Client Secret. Default: <code>None</code> <code>GOOGLE_SSO_ENABLED</code> Enable or disable the plugin. Default: <code>True</code> <code>GOOGLE_SSO_PROJECT_ID</code> The Google OAuth 2.0 Project ID. Default: <code>None</code> <code>GOOGLE_SSO_SCOPES</code> The Google OAuth 2.0 Scopes. Default: <code>[\"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\"]</code> <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code> The age of the session cookie in seconds. Default: <code>3600</code> <code>GOOGLE_SSO_STAFF_LIST</code> List of emails that will be created as staff. Default: <code>[]</code> <code>GOOGLE_SSO_SUPERUSER_LIST</code> List of emails that will be created as superuser. Default: <code>[]</code> <code>GOOGLE_SSO_TIMEOUT</code> The timeout in seconds for the Google SSO authentication returns info, in minutes. Default: <code>10</code> <code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code> Callable for processing pre-login logic. Default: <code>django_google_sso.hooks.pre_login_user</code>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>stela: Easily manage project settings and secrets in any python project.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-errors","title":"Common errors:","text":"Admin Message: State Mismatched. Time expired? <p>This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found. Please check if the browser has the anonymous session created by Django.</p> Google show the message: The Solicitation from App XXX is Invalid. <p>Make sure you have added the correct Callback URI on Google Console. Please remember the trailing slash for this URI..</p>"},{"location":"troubleshooting/#example-app","title":"Example App","text":"<p>To test this library please check the <code>Example App</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"urls/","title":"Setup Django URLs","text":"<p>The base configuration for Django URLs is the same we have described as before: <pre><code># urls.py\nfrom django.urls import include, path\nurlpatterns = [\n# other urlpatterns...\npath(\n\"google_sso/\", include(\n\"django_google_sso.urls\",\nnamespace=\"django_google_sso\"\n)\n),\n]\n</code></pre> You can change the initial Path - <code>google_sso/</code> - to whatever you want - just remember to change it in the Google Console as well.</p>"},{"location":"urls/#overriding-the-login-view-or-path","title":"Overriding the Login view or Path","text":"<p>If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template:</p> <pre><code>from django.contrib.auth.views import LoginView\nfrom django.urls import path\nurlpatterns = [\n# other urlpatterns...\npath(\n\"accounts/login/\",\nLoginView.as_view(\n# The modified form with Google button\ntemplate_name=\"admin_sso/login.html\"\n),\n),\n]\n</code></pre> <p>or</p> <pre><code>from django.contrib.auth.views import LoginView\nclass MyLoginView(LoginView):\ntemplate_name = \"admin_sso/login.html\"\n</code></pre>"},{"location":"users/","title":"Auto Creating Users","text":"<p>Django Google SSO can automatically create users from Google SSO authentication. To enable this feature, you need to set the <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code> setting in your <code>settings.py</code>, with a list of domains that will be allowed to create. For example, if any user with a gmail account can sign in, you can set:</p> <pre><code># settings.py\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"gmail.com\"]\n</code></pre>"},{"location":"users/#disabling-the-auto-create-users","title":"Disabling the auto-create users","text":"<p>You can disable the auto-create users feature by setting the <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> setting to <code>False</code>:</p> <pre><code>GOOGLE_SSO_AUTO_CREATE_USERS = False\n</code></pre> <p>You can also disable the plugin completely:</p> <pre><code>GOOGLE_SSO_ENABLED = False\n</code></pre>"},{"location":"users/#giving-permissions-to-auto-created-users","title":"Giving Permissions to Auto-Created Users","text":"<p>If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this you can set the following options in your <code>settings.py</code>:</p> <pre><code># List of emails that will be created as staff\nGOOGLE_SSO_STAFF_LIST = [\"my-email@my-domain.com\"]\n# List of emails that will be created as superuser\nGOOGLE_SSO_SUPERUSER_LIST = [\"another-email@my-domain.com\"]\n# If True, the first user that logs in will be created as superuser\n# if no superuser exists in the database at all\nGOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = True\n</code></pre>"},{"location":"users/#fine-tuning-users-before-login","title":"Fine-tuning users before login","text":"<p>If you need to do some processing after user is created or retrieved, but before the user is logged in, you can set the <code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code> setting to import a custom function that will be called before the user is logged in. This function will receive two arguments: the <code>user</code> and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_login_user(user, request):\n# Do something with the user\npass\n# settings.py\nGOOGLE_SSO_PRE_LOGIN_CALLBACK = \"myapp.hooks.pre_login_user\"\n</code></pre> <p>Please remember this function will be invoked only if user exists, and if it is active. In other words, if the user is eligible for login.</p> <p>Be careful with these options</p> <p>The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options.</p> <p>For the last step, we will look at the Django URLs.</p>"}]}