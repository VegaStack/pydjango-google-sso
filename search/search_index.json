{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Django Google SSO \u00b6 Motivation \u00b6 This library aims to simplify the process of authenticating users with Google in Django Admin pages, inspired by libraries like django_microsoft_auth and django-admin-sso Why another library? \u00b6 This library aims for simplicity and ease of use. django-allauth is de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates. Django-Google-SSO just add the \"Login with Google\" button in the default login page. Light Mode Dark Mode django-admin-sso is a good solution, but it uses a deprecated google auth2client version. Install \u00b6 pip install django-google-sso Currently this project supports: Python 3.8, 3.9, 3.10 and 3.11 Django 3.2, 4.0 and 4.1","title":"Intro"},{"location":"#welcome-to-django-google-sso","text":"","title":"Welcome to Django Google SSO"},{"location":"#motivation","text":"This library aims to simplify the process of authenticating users with Google in Django Admin pages, inspired by libraries like django_microsoft_auth and django-admin-sso","title":"Motivation"},{"location":"#why-another-library","text":"This library aims for simplicity and ease of use. django-allauth is de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates. Django-Google-SSO just add the \"Login with Google\" button in the default login page. Light Mode Dark Mode django-admin-sso is a good solution, but it uses a deprecated google auth2client version.","title":"Why another library?"},{"location":"#install","text":"pip install django-google-sso Currently this project supports: Python 3.8, 3.9, 3.10 and 3.11 Django 3.2, 4.0 and 4.1","title":"Install"},{"location":"admin/","text":"Using Django Admin \u00b6 Django Google SSO integrates with Django Admin, adding a Inline Model Admin to the User model. This way, you can access the Google SSO data for each user. Using Custom User model \u00b6 If you are using a custom user model, you may need to add the GoogleSSOInlineAdmin inline model admin to your custom user model admin, like this: # admin.py from django.contrib import admin from django.contrib.auth import get_user_model from django.contrib.auth.admin import UserAdmin from django_google_sso.admin import GoogleSSOInlineAdmin CustomUser = get_user_model() if admin.site.is_registered(CustomUser): admin.site.unregister(CustomUser) @admin.register(CustomUser) class CustomUserAdmin(UserAdmin): inlines = [GoogleSSOInlineAdmin]","title":"Using Django Admin"},{"location":"admin/#using-django-admin","text":"Django Google SSO integrates with Django Admin, adding a Inline Model Admin to the User model. This way, you can access the Google SSO data for each user.","title":"Using Django Admin"},{"location":"admin/#using-custom-user-model","text":"If you are using a custom user model, you may need to add the GoogleSSOInlineAdmin inline model admin to your custom user model admin, like this: # admin.py from django.contrib import admin from django.contrib.auth import get_user_model from django.contrib.auth.admin import UserAdmin from django_google_sso.admin import GoogleSSOInlineAdmin CustomUser = get_user_model() if admin.site.is_registered(CustomUser): admin.site.unregister(CustomUser) @admin.register(CustomUser) class CustomUserAdmin(UserAdmin): inlines = [GoogleSSOInlineAdmin]","title":"Using Custom User model"},{"location":"callback/","text":"Get your Callback URI \u00b6 The callback URL is the URL where Google will redirect the user after the authentication process. This URL must be registered in your Google project. The Callback URI \u00b6 The callback URI is composed of {scheme}://{netloc}/{path}/ , where the netloc is the domain name of your Django project, and the path is /google_sso/callback/ . For example, if your Django project is hosted on https://myproject.com , then the callback URL will be https://myproject.com/google_sso/callback/ . So, let's break each part of this URI: The scheme \u00b6 The scheme is the protocol used to access the URL. It can be http or https . Django-Google-SSO will select the same scheme used by the URL which shows to you the login page. For example, if you are running locally, like http://localhost:8000/accounts/login , then the callback URL scheme will be http:// . How about a Reverse-Proxy? If you're running Django behind a reverse-proxy, please make sure you're passing the correct X-Forwarded-Proto header to the login request URL. The NetLoc \u00b6 The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: example.com , localhost:8000 , api.my-domain.com , and so on. To find the correct netloc, Django-Google-SSO will check, in that order: If settings contains the variable GOOGLE_SSO_CALLBACK_DOMAIN , it will use this value. If Sites Framework is active, it will use the domain field for the current site. The netloc found in the URL which shows to you the login page. The Path \u00b6 The path is the path to the callback view. It will be always /<path in urls.py>/callback/ . Remember when you add this to the urls.py ? from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ] The path starts with the google_sso/ part. If you change this to sso/ for example, your callback URL will change to https://myproject.com/sso/callback/ . Registering the URI \u00b6 To register the callback URL, in your Google project , add the callback URL in the Authorized redirect URIs field, clicking on button Add URI . Then add your full URL and click on Save . Do not forget the trailing slash Many errors on this step are caused by forgetting the trailing slash: Good: http://localhost:8000/google_sso/callback/ Bad: http://localhost:8000/google_sso/callback In the next step, we will configure Django-Google-SSO to auto create the Users.","title":"Get your Callback URI"},{"location":"callback/#get-your-callback-uri","text":"The callback URL is the URL where Google will redirect the user after the authentication process. This URL must be registered in your Google project.","title":"Get your Callback URI"},{"location":"callback/#the-callback-uri","text":"The callback URI is composed of {scheme}://{netloc}/{path}/ , where the netloc is the domain name of your Django project, and the path is /google_sso/callback/ . For example, if your Django project is hosted on https://myproject.com , then the callback URL will be https://myproject.com/google_sso/callback/ . So, let's break each part of this URI:","title":"The Callback URI"},{"location":"callback/#the-scheme","text":"The scheme is the protocol used to access the URL. It can be http or https . Django-Google-SSO will select the same scheme used by the URL which shows to you the login page. For example, if you are running locally, like http://localhost:8000/accounts/login , then the callback URL scheme will be http:// . How about a Reverse-Proxy? If you're running Django behind a reverse-proxy, please make sure you're passing the correct X-Forwarded-Proto header to the login request URL.","title":"The scheme"},{"location":"callback/#the-netloc","text":"The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: example.com , localhost:8000 , api.my-domain.com , and so on. To find the correct netloc, Django-Google-SSO will check, in that order: If settings contains the variable GOOGLE_SSO_CALLBACK_DOMAIN , it will use this value. If Sites Framework is active, it will use the domain field for the current site. The netloc found in the URL which shows to you the login page.","title":"The NetLoc"},{"location":"callback/#the-path","text":"The path is the path to the callback view. It will be always /<path in urls.py>/callback/ . Remember when you add this to the urls.py ? from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ] The path starts with the google_sso/ part. If you change this to sso/ for example, your callback URL will change to https://myproject.com/sso/callback/ .","title":"The Path"},{"location":"callback/#registering-the-uri","text":"To register the callback URL, in your Google project , add the callback URL in the Authorized redirect URIs field, clicking on button Add URI . Then add your full URL and click on Save . Do not forget the trailing slash Many errors on this step are caused by forgetting the trailing slash: Good: http://localhost:8000/google_sso/callback/ Bad: http://localhost:8000/google_sso/callback In the next step, we will configure Django-Google-SSO to auto create the Users.","title":"Registering the URI"},{"location":"credentials/","text":"Adding Google Credentials \u00b6 To make the SSO work, we need to set up, in your Django project, the Google credentials needed to perform the authentication. Getting Google Credentials \u00b6 In your Google Console navigate to Api -> Credentials to access the credentials your for your all Google Cloud Projects. Your first Google Cloud Project If you don't have a Google Cloud Project, you can create one by clicking on the Create button. Then, you can select one of existing Web App Oauth 2.0 Client Ids in you Google project, or create a new one. Do I need to create a new Oauth 2.0 Client Web App? Normally you will have one credential per environment in your Django project. For example, if you have a development , staging and production environments, then you will have three credentials, one for each one. This mitigates the risk of exposing all your data in case of a security breach. If you decide to create a new one, please check https://developers.google.com/identity/protocols/oauth2/ for additional info. When you open your Web App Client Id, please get the following information: The Client ID . This is something like XXXX.apps.googleusercontent.com and will be the GOOGLE_SSO_CLIENT_ID in your Django project. The Client Secret Key . This is a long string and will be the GOOGLE_SSO_CLIENT_SECRET in your Django project. The Project ID . This is the Project ID, you can get click on the Project Name, and will be the GOOGLE_SSO_PROJECT_ID in your Django project. After that, add them in your settings.py file: # settings.py GOOGLE_SSO_CLIENT_ID = \"your client id here\" GOOGLE_SSO_CLIENT_SECRET = \"your client secret here\" GOOGLE_SSO_PROJECT_ID = \"your project id here\" Don't commit this info Do not commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we are recommend you to use environment variables to store this info. To read this data, you will need to install a Twelve-factor compatible library in your project. For example, you can use our sister project stela to load the environment variables from a .env file, like this: ```dotenv .env \u00b6 GOOGLE_SSO_CLIENT_ID=\"your client id here\" GOOGLE_SSO_CLIENT_SECRET=\"your client secret here\" GOOGLE_SSO_PROJECT_ID=\"your project id here\" ``` ```python settings.py \u00b6 import os from stela import settings GOOGLE_SSO_CLIENT_ID = settings[\"GOOGLE_SSO_CLIENT_ID\"] GOOGLE_SSO_CLIENT_SECRET = settings[\"GOOGLE_SSO_CLIENT_SECRET\"] GOOGLE_SSO_PROJECT_ID = settings[\"GOOGLE_SSO_PROJECT_ID\"] ``` But in fact, you can use any library you want, like django-environ , django-constance , python-dotenv , etc... In the next step, we need to configure the authorized callback URI for your Django project.","title":"Adding Google Credentials"},{"location":"credentials/#adding-google-credentials","text":"To make the SSO work, we need to set up, in your Django project, the Google credentials needed to perform the authentication.","title":"Adding Google Credentials"},{"location":"credentials/#getting-google-credentials","text":"In your Google Console navigate to Api -> Credentials to access the credentials your for your all Google Cloud Projects. Your first Google Cloud Project If you don't have a Google Cloud Project, you can create one by clicking on the Create button. Then, you can select one of existing Web App Oauth 2.0 Client Ids in you Google project, or create a new one. Do I need to create a new Oauth 2.0 Client Web App? Normally you will have one credential per environment in your Django project. For example, if you have a development , staging and production environments, then you will have three credentials, one for each one. This mitigates the risk of exposing all your data in case of a security breach. If you decide to create a new one, please check https://developers.google.com/identity/protocols/oauth2/ for additional info. When you open your Web App Client Id, please get the following information: The Client ID . This is something like XXXX.apps.googleusercontent.com and will be the GOOGLE_SSO_CLIENT_ID in your Django project. The Client Secret Key . This is a long string and will be the GOOGLE_SSO_CLIENT_SECRET in your Django project. The Project ID . This is the Project ID, you can get click on the Project Name, and will be the GOOGLE_SSO_PROJECT_ID in your Django project. After that, add them in your settings.py file: # settings.py GOOGLE_SSO_CLIENT_ID = \"your client id here\" GOOGLE_SSO_CLIENT_SECRET = \"your client secret here\" GOOGLE_SSO_PROJECT_ID = \"your project id here\" Don't commit this info Do not commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we are recommend you to use environment variables to store this info. To read this data, you will need to install a Twelve-factor compatible library in your project. For example, you can use our sister project stela to load the environment variables from a .env file, like this: ```dotenv","title":"Getting Google Credentials"},{"location":"credentials/#env","text":"GOOGLE_SSO_CLIENT_ID=\"your client id here\" GOOGLE_SSO_CLIENT_SECRET=\"your client secret here\" GOOGLE_SSO_PROJECT_ID=\"your project id here\" ``` ```python","title":".env"},{"location":"credentials/#settingspy","text":"import os from stela import settings GOOGLE_SSO_CLIENT_ID = settings[\"GOOGLE_SSO_CLIENT_ID\"] GOOGLE_SSO_CLIENT_SECRET = settings[\"GOOGLE_SSO_CLIENT_SECRET\"] GOOGLE_SSO_PROJECT_ID = settings[\"GOOGLE_SSO_PROJECT_ID\"] ``` But in fact, you can use any library you want, like django-environ , django-constance , python-dotenv , etc... In the next step, we need to configure the authorized callback URI for your Django project.","title":"settings.py"},{"location":"how/","text":"How Django Google SSO works? \u00b6 Current Flow \u00b6 First, the user is redirected to the Django login page. If settings GOOGLE_SSO_ENABLED is True, the \"Login with Google\" button will be added to default form. On click, Django-Google-SSO will add, in a anonymous request session, the next_path and Google Flow state . This data will expire in 10 minutes. Then user will be redirected to Google login page. Using Request Anonymous session If you make any actions which changes or destroy this session, like restart django, clear cookies or change browsers, the login will fail and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again. On callback, Django-Google-SSO will check code and state received. If they are valid, Google's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in. Otherwise, the user will be created and logged in, if his email domain, matches one of the GOOGLE_SSO_ALLOWABLE_DOMAINS . You can disable the auto-creation setting GOOGLE_SSO_AUTO_CREATE_USER to False. On creation only, this user can be set to the staff or superuser status, if his email are in GOGGLE_SSO_STAFF_LIST or GOGGLE_SSO_SUPERUSER_LIST respectively. Please note if you add an email to one of these lists, the email domain must be added to GOOGLE_SSO_ALLOWABLE_DOMAINS too. This authenticated session will expire in 1 hour, or the time defined, in seconds, in GOOGLE_SSO_SESSION_COOKIE_AGE . Browser will be redirected to next_path if operation succeeds, or the login page, if operation fails. Using Custom Authentication Backend \u00b6 If the users need to log in using a custom authentication backend, you can use the GOOGLE_SSO_AUTHENTICATION_BACKEND setting: # settings.py GOOGLE_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"","title":"How Django Google SSO works?"},{"location":"how/#how-django-google-sso-works","text":"","title":"How Django Google SSO works?"},{"location":"how/#current-flow","text":"First, the user is redirected to the Django login page. If settings GOOGLE_SSO_ENABLED is True, the \"Login with Google\" button will be added to default form. On click, Django-Google-SSO will add, in a anonymous request session, the next_path and Google Flow state . This data will expire in 10 minutes. Then user will be redirected to Google login page. Using Request Anonymous session If you make any actions which changes or destroy this session, like restart django, clear cookies or change browsers, the login will fail and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again. On callback, Django-Google-SSO will check code and state received. If they are valid, Google's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in. Otherwise, the user will be created and logged in, if his email domain, matches one of the GOOGLE_SSO_ALLOWABLE_DOMAINS . You can disable the auto-creation setting GOOGLE_SSO_AUTO_CREATE_USER to False. On creation only, this user can be set to the staff or superuser status, if his email are in GOGGLE_SSO_STAFF_LIST or GOGGLE_SSO_SUPERUSER_LIST respectively. Please note if you add an email to one of these lists, the email domain must be added to GOOGLE_SSO_ALLOWABLE_DOMAINS too. This authenticated session will expire in 1 hour, or the time defined, in seconds, in GOOGLE_SSO_SESSION_COOKIE_AGE . Browser will be redirected to next_path if operation succeeds, or the login page, if operation fails.","title":"Current Flow"},{"location":"how/#using-custom-authentication-backend","text":"If the users need to log in using a custom authentication backend, you can use the GOOGLE_SSO_AUTHENTICATION_BACKEND setting: # settings.py GOOGLE_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"","title":"Using Custom Authentication Backend"},{"location":"model/","text":"Getting Google info \u00b6 The User model \u00b6 Django Google SSO saves in the database the following information from Google, using current User model: email : The email address of the user. first_name : The first name of the user. last_name : The last name of the user. username : The email address of the user. password : An unusable password, generated using get_unusable_password() from Django. Getting data on code is straightforward: from django.contrib.auth.decorators import login_required from django.http import JsonResponse, HttpRequest @login_required def retrieve_user_data(request: HttpRequest) -> JsonResponse: user = request.user return JsonResponse({ \"email\": user.email, \"first_name\": user.first_name, \"last_name\": user.last_name, \"username\": user.username, }) The GoogleSSOUser model \u00b6 Also, on the GoogleSSOUser model, it saves the following information: picture_url : The URL of the user's profile picture. google_id : The Google ID of the user. locale : The preferred locale of the user. This is a one-to-one relationship with the User model, so you can access this data using the googlessouser reverse relation attribute: from django.contrib.auth.decorators import login_required from django.http import JsonResponse, HttpRequest @login_required def retrieve_user_data(request: HttpRequest) -> JsonResponse: user = request.user return JsonResponse({ \"email\": user.email, \"first_name\": user.first_name, \"last_name\": user.last_name, \"username\": user.username, \"picture\": user.googlessouser.picture_url, \"google_id\": user.googlessouser.google_id, \"locale\": user.googlessouser.locale, }) You can also import the model directly Like this: ```python from django_google_sso.models import GoogleSSOUser google_info = GoogleSSOUser.objects.get(user=user) ``` About Google Scopes \u00b6 To retrieve this data Django Google SSO uses the following scopes for Google OAuth 2.0 : GOOGLE_SSO_SCOPES = [ # Google default scope \"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\", ] You can change this scopes overriding the GOOGLE_SSO_SCOPES setting in your settings.py file. But if you ask the user to authorize more scopes, this additional data will not be saved in the database by this plugin. You will need to implement your own logic to save this data, calling google again. The main goal here is simplicity The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.","title":"Getting Google info"},{"location":"model/#getting-google-info","text":"","title":"Getting Google info"},{"location":"model/#the-user-model","text":"Django Google SSO saves in the database the following information from Google, using current User model: email : The email address of the user. first_name : The first name of the user. last_name : The last name of the user. username : The email address of the user. password : An unusable password, generated using get_unusable_password() from Django. Getting data on code is straightforward: from django.contrib.auth.decorators import login_required from django.http import JsonResponse, HttpRequest @login_required def retrieve_user_data(request: HttpRequest) -> JsonResponse: user = request.user return JsonResponse({ \"email\": user.email, \"first_name\": user.first_name, \"last_name\": user.last_name, \"username\": user.username, })","title":"The User model"},{"location":"model/#the-googlessouser-model","text":"Also, on the GoogleSSOUser model, it saves the following information: picture_url : The URL of the user's profile picture. google_id : The Google ID of the user. locale : The preferred locale of the user. This is a one-to-one relationship with the User model, so you can access this data using the googlessouser reverse relation attribute: from django.contrib.auth.decorators import login_required from django.http import JsonResponse, HttpRequest @login_required def retrieve_user_data(request: HttpRequest) -> JsonResponse: user = request.user return JsonResponse({ \"email\": user.email, \"first_name\": user.first_name, \"last_name\": user.last_name, \"username\": user.username, \"picture\": user.googlessouser.picture_url, \"google_id\": user.googlessouser.google_id, \"locale\": user.googlessouser.locale, }) You can also import the model directly Like this: ```python from django_google_sso.models import GoogleSSOUser google_info = GoogleSSOUser.objects.get(user=user) ```","title":"The GoogleSSOUser model"},{"location":"model/#about-google-scopes","text":"To retrieve this data Django Google SSO uses the following scopes for Google OAuth 2.0 : GOOGLE_SSO_SCOPES = [ # Google default scope \"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\", ] You can change this scopes overriding the GOOGLE_SSO_SCOPES setting in your settings.py file. But if you ask the user to authorize more scopes, this additional data will not be saved in the database by this plugin. You will need to implement your own logic to save this data, calling google again. The main goal here is simplicity The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.","title":"About Google Scopes"},{"location":"quick_setup/","text":"Quick Setup \u00b6 Setup Django Settings \u00b6 To add this package in your Django Project, please modify the INSTALLED_APPS in your settings.py : # settings.py INSTALLED_APPS = [ # other django apps \"django.contrib.messages\", # Need for Auth messages \"django_google_sso\", # Add django_google_sso ] Setup Google Credentials \u00b6 Now, add your Google Project Web App API Credentials in your settings.py : # settings.py GOOGLE_SSO_CLIENT_ID = \"your Web App Client Id here\" GOOGLE_SSO_CLIENT_SECRET = \"your Web App Client Secret here\" GOOGLE_SSO_PROJECT_ID = \"your Google Project Id here\" Setup Callback URI \u00b6 In Google Console at Api -> Credentials -> Oauth2 Client , add the following Authorized Redirect URI : https://your-domain.com/google_sso/callback/ replacing your-domain.com with your real domain (and Port). For example, if you are running locally, you can use http://localhost:8000/google_sso/callback/ . Do not forget the trailing slash! Setup Auto-Create Users \u00b6 The next option is to set up the auto-create users from Django Google SSO. Only emails with the allowed domains will be created automatically. If the email is not in the allowed domains, the user will be redirected to the login page. # settings.py GOOGLE_SSO_ALLOWABLE_DOMAINS = [\"your-domain.com\"] Setup Django URLs \u00b6 And in your urls.py please add the Django-Google-SSO views: # urls.py from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ] Run Django migrations \u00b6 Finally, run migrations python manage.py migrate And, that's it: Django Google SSO is ready for use. When you open the admin page, you will see the \"Login with Google\" button: Light Mode Dark Mode How about Django Admin skins, like Grappelli? Django Google SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli , Django Jazzmin , Django Admin Interface and Django Jet Reboot . If the skin uses his own login template, the \"Login with Google\" button will not be displayed. For the next pages, lets see each one of these steps with more details.","title":"Quick Setup"},{"location":"quick_setup/#quick-setup","text":"","title":"Quick Setup"},{"location":"quick_setup/#setup-django-settings","text":"To add this package in your Django Project, please modify the INSTALLED_APPS in your settings.py : # settings.py INSTALLED_APPS = [ # other django apps \"django.contrib.messages\", # Need for Auth messages \"django_google_sso\", # Add django_google_sso ]","title":"Setup Django Settings"},{"location":"quick_setup/#setup-google-credentials","text":"Now, add your Google Project Web App API Credentials in your settings.py : # settings.py GOOGLE_SSO_CLIENT_ID = \"your Web App Client Id here\" GOOGLE_SSO_CLIENT_SECRET = \"your Web App Client Secret here\" GOOGLE_SSO_PROJECT_ID = \"your Google Project Id here\"","title":"Setup Google Credentials"},{"location":"quick_setup/#setup-callback-uri","text":"In Google Console at Api -> Credentials -> Oauth2 Client , add the following Authorized Redirect URI : https://your-domain.com/google_sso/callback/ replacing your-domain.com with your real domain (and Port). For example, if you are running locally, you can use http://localhost:8000/google_sso/callback/ . Do not forget the trailing slash!","title":"Setup Callback URI"},{"location":"quick_setup/#setup-auto-create-users","text":"The next option is to set up the auto-create users from Django Google SSO. Only emails with the allowed domains will be created automatically. If the email is not in the allowed domains, the user will be redirected to the login page. # settings.py GOOGLE_SSO_ALLOWABLE_DOMAINS = [\"your-domain.com\"]","title":"Setup Auto-Create Users"},{"location":"quick_setup/#setup-django-urls","text":"And in your urls.py please add the Django-Google-SSO views: # urls.py from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ]","title":"Setup Django URLs"},{"location":"quick_setup/#run-django-migrations","text":"Finally, run migrations python manage.py migrate And, that's it: Django Google SSO is ready for use. When you open the admin page, you will see the \"Login with Google\" button: Light Mode Dark Mode How about Django Admin skins, like Grappelli? Django Google SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli , Django Jazzmin , Django Admin Interface and Django Jet Reboot . If the skin uses his own login template, the \"Login with Google\" button will not be displayed. For the next pages, lets see each one of these steps with more details.","title":"Run Django migrations"},{"location":"settings/","text":"All Django Settings options \u00b6 Setting Description GOOGLE_SSO_ALLOWABLE_DOMAINS List of domains that will be allowed to create users. Default: [] GOOGLE_SSO_AUTHENTICATION_BACKEND The authentication backend to use. Default: None GOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: False GOOGLE_SSO_AUTO_CREATE_USERS Enable or disable the auto-create users feature. Default: True GOOGLE_SSO_CALLBACK_DOMAIN The netloc to be used on Callback URI. Default: None GOOGLE_SSO_CLIENT_ID The Google OAuth 2.0 Web Application Client ID. Default: None GOOGLE_SSO_CLIENT_SECRET The Google OAuth 2.0 Web Application Client Secret. Default: None GOOGLE_SSO_ENABLED Enable or disable the plugin. Default: True GOOGLE_SSO_PROJECT_ID The Google OAuth 2.0 Project ID. Default: None GOOGLE_SSO_SCOPES The Google OAuth 2.0 Scopes. Default: [\"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\"] GOOGLE_SSO_SESSION_COOKIE_AGE The age of the session cookie in seconds. Default: 3600 GOOGLE_SSO_STAFF_LIST List of emails that will be created as staff. Default: [] GOOGLE_SSO_SUPERUSER_LIST List of emails that will be created as superuser. Default: [] GOOGLE_SSO_TIMEOUT The timeout in seconds for the Google SSO authentication returns info, in minutes. Default: 10","title":"All Django Settings options"},{"location":"settings/#all-django-settings-options","text":"Setting Description GOOGLE_SSO_ALLOWABLE_DOMAINS List of domains that will be allowed to create users. Default: [] GOOGLE_SSO_AUTHENTICATION_BACKEND The authentication backend to use. Default: None GOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: False GOOGLE_SSO_AUTO_CREATE_USERS Enable or disable the auto-create users feature. Default: True GOOGLE_SSO_CALLBACK_DOMAIN The netloc to be used on Callback URI. Default: None GOOGLE_SSO_CLIENT_ID The Google OAuth 2.0 Web Application Client ID. Default: None GOOGLE_SSO_CLIENT_SECRET The Google OAuth 2.0 Web Application Client Secret. Default: None GOOGLE_SSO_ENABLED Enable or disable the plugin. Default: True GOOGLE_SSO_PROJECT_ID The Google OAuth 2.0 Project ID. Default: None GOOGLE_SSO_SCOPES The Google OAuth 2.0 Scopes. Default: [\"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\"] GOOGLE_SSO_SESSION_COOKIE_AGE The age of the session cookie in seconds. Default: 3600 GOOGLE_SSO_STAFF_LIST List of emails that will be created as staff. Default: [] GOOGLE_SSO_SUPERUSER_LIST List of emails that will be created as superuser. Default: [] GOOGLE_SSO_TIMEOUT The timeout in seconds for the Google SSO authentication returns info, in minutes. Default: 10","title":"All Django Settings options"},{"location":"thanks/","text":"Thank you \u00b6 Thank you for using this project. And for all the appreciation, patience and support. I really hope this project can make your life a little easier. Please feel free to check my other projects: stela : Easily manage project settings and secrets in python projects. Donating \u00b6 If you like to finance this project, please consider donating:","title":"Thank you"},{"location":"thanks/#thank-you","text":"Thank you for using this project. And for all the appreciation, patience and support. I really hope this project can make your life a little easier. Please feel free to check my other projects: stela : Easily manage project settings and secrets in python projects.","title":"Thank you"},{"location":"thanks/#donating","text":"If you like to finance this project, please consider donating:","title":"Donating"},{"location":"troubleshooting/","text":"Troubleshooting Guide \u00b6 Common errors: \u00b6 Admin Message: State Mismatched. Time expired? This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found. Please check if browser has the anonymous session created by Django. Google show the message: The Solicitation from App XXX is Invalid. Make sure you have added the correct Callback URI on Google Console. Please remember the trailing slash for this URI.. Example App \u00b6 To test this library please check the Example App provided here . Not working? \u00b6 Don't panic. Get a towel and, please, open an issue .","title":"Troubleshooting Guide"},{"location":"troubleshooting/#troubleshooting-guide","text":"","title":"Troubleshooting Guide"},{"location":"troubleshooting/#common-errors","text":"Admin Message: State Mismatched. Time expired? This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found. Please check if browser has the anonymous session created by Django. Google show the message: The Solicitation from App XXX is Invalid. Make sure you have added the correct Callback URI on Google Console. Please remember the trailing slash for this URI..","title":"Common errors:"},{"location":"troubleshooting/#example-app","text":"To test this library please check the Example App provided here .","title":"Example App"},{"location":"troubleshooting/#not-working","text":"Don't panic. Get a towel and, please, open an issue .","title":"Not working?"},{"location":"urls/","text":"Setup Django URLs \u00b6 The base configuration for Django URLs is the same we have described as before: # urls.py from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ] You can change the initial Path - google_sso/ - to whatever you want - just remember to change it in the Google Console as well. Overriding the Login view or Path \u00b6 If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template: from django.contrib.auth.views import LoginView from django.urls import path urlpatterns = [ # other urlpatterns... path( \"accounts/login/\", LoginView.as_view( # The modified form with Google button template_name=\"admin_sso/login.html\" ), ), ] or from django.contrib.auth.views import LoginView class MyLoginView(LoginView): template_name = \"admin_sso/login.html\"","title":"Setup Django URLs"},{"location":"urls/#setup-django-urls","text":"The base configuration for Django URLs is the same we have described as before: # urls.py from django.urls import include, path urlpatterns = [ # other urlpatterns... path( \"google_sso/\", include(\"django_google_sso.urls\", namespace=\"django_google_sso\") ), ] You can change the initial Path - google_sso/ - to whatever you want - just remember to change it in the Google Console as well.","title":"Setup Django URLs"},{"location":"urls/#overriding-the-login-view-or-path","text":"If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template: from django.contrib.auth.views import LoginView from django.urls import path urlpatterns = [ # other urlpatterns... path( \"accounts/login/\", LoginView.as_view( # The modified form with Google button template_name=\"admin_sso/login.html\" ), ), ] or from django.contrib.auth.views import LoginView class MyLoginView(LoginView): template_name = \"admin_sso/login.html\"","title":"Overriding the Login view or Path"},{"location":"users/","text":"Auto Create Users \u00b6 Django Google SSO can automatically create users from Google SSO authentication. To enable this feature, you need to set the GOOGLE_SSO_ALLOWABLE_DOMAINS setting in your settings.py , with a list of domains that will be allowed to create. For example, if any user with a gmail account can sign in, you can set: # settings.py GOOGLE_SSO_ALLOWABLE_DOMAINS = [\"gmail.com\"] Disabling the auto-create users \u00b6 You can disable the auto-create users feature by setting the GOOGLE_SSO_AUTO_CREATE_USERS setting to False : GOOGLE_SSO_AUTO_CREATE_USERS = False You can also disable the plugin completely: GOOGLE_SSO_ENABLED = False Giving Permissions to Auto-Created Users \u00b6 If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this you can set the following options in your settings.py : # List of emails that will be created as staff GOGGLE_SSO_STAFF_LIST = [\"my-email@my-domain.com\"] # List of emails that will be created as superuser GOOGLE_SSO_SUPERUSER_LIST = [\"another-email@my-domain.com\"] # If True, the first user that logs in will be created as superuser # if no superuser exists in the database at all GOGGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = True Be careful with these options The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options. For the last step, we will look at the Django URLs.","title":"Auto Create Users"},{"location":"users/#auto-create-users","text":"Django Google SSO can automatically create users from Google SSO authentication. To enable this feature, you need to set the GOOGLE_SSO_ALLOWABLE_DOMAINS setting in your settings.py , with a list of domains that will be allowed to create. For example, if any user with a gmail account can sign in, you can set: # settings.py GOOGLE_SSO_ALLOWABLE_DOMAINS = [\"gmail.com\"]","title":"Auto Create Users"},{"location":"users/#disabling-the-auto-create-users","text":"You can disable the auto-create users feature by setting the GOOGLE_SSO_AUTO_CREATE_USERS setting to False : GOOGLE_SSO_AUTO_CREATE_USERS = False You can also disable the plugin completely: GOOGLE_SSO_ENABLED = False","title":"Disabling the auto-create users"},{"location":"users/#giving-permissions-to-auto-created-users","text":"If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this you can set the following options in your settings.py : # List of emails that will be created as staff GOGGLE_SSO_STAFF_LIST = [\"my-email@my-domain.com\"] # List of emails that will be created as superuser GOOGLE_SSO_SUPERUSER_LIST = [\"another-email@my-domain.com\"] # If True, the first user that logs in will be created as superuser # if no superuser exists in the database at all GOGGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = True Be careful with these options The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options. For the last step, we will look at the Django URLs.","title":"Giving Permissions to Auto-Created Users"}]}